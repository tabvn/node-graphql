{"version":3,"sources":["../src/realtime.js"],"names":["Realtime","ctx","wss","connections","listenWebSocketClients","userId","clients","isValid","toString","filter","con","userIds","message","length","includes","size","forEach","client","sendMessage","id","getClient","get","set","delete","on","ws","clientId","generateClientId","authenticated","setClient","onMessage","onDisconnected","json","JSON","parse","err","console","log","messageToJson","handleReceivedMessageEvent","action","payload","auth","logout","tokenId","setWith","getClientsByUserId","models","user","updateAttribute","online","then","token","isAuthenticated","authSuccess","load","catch","authError","stringify","send","removeClient","findClient","find"],"mappings":"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","file":"realtime.js","sourcesContent":["import _ from 'lodash'\nimport {ObjectID} from 'mongodb';\n\nimport {Map} from 'immutable'\n\n\nexport default class Realtime {\n\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.wss = ctx.wss;\n        // Store WebSocket Client in cache.\n        this.connections = new Map();\n\n        this.listenWebSocketClients();\n    }\n\n    /**\n     * Find WebSocket client by UserId\n     * @param userId\n     * @returns {*}\n     */\n\n    getClientsByUserId(userId) {\n\n        let clients = [];\n\n        if (!userId || !ObjectID.isValid(userId)) {\n            return clients;\n        }\n\n        if (typeof userId !== 'string') {\n\n            userId = _.toString(userId);\n        }\n\n        return this.connections.filter((con) => _.toString(con.userId) === userId);\n    }\n\n    /**\n     * Send message to users by IDs\n     * @param userIds\n     * @param message\n     */\n    sendToUsers(userIds = [], message) {\n        if (!userIds || userIds.length === 0 || !message) {\n            return\n        }\n\n        const connections = this.connections.filter((con) => _.includes(userIds, _.toString(con.userId)));\n\n\n        if (connections && connections.size > 0) {\n            connections.forEach((client) => {\n\n\n                this.sendMessage(client, message);\n\n            });\n        }\n    }\n\n\n    /**\n     * Generate WebSocket client id\n     */\n    generateClientId() {\n\n        return new ObjectID().toString();\n    }\n\n    /**\n     * Check if client is authenticated\n     * @param id\n     */\n\n    isAuthenticated(id) {\n\n        const client = this.getClient(id);\n        return _.get(client, 'authenticated', false);\n    }\n\n    /**\n     * Save WebSocket client to cache\n     * @param id\n     * @param ws\n     * @returns {{id: *, userId: null, token: null, authenticated: boolean, ws: *, created: Date}}\n     */\n    setClient(id, client) {\n\n        this.connections = this.connections.set(id, client);\n        return client;\n\n\n    }\n\n    /**\n     * Get WebSocket Client Info\n     * @param id\n     * @returns {ws:*, userId: ObjectId, authenticated: boolean} or null if empty\n     */\n\n    getClient(id) {\n        const client = this.connections.get(id);\n        return client ? client : null;\n    }\n\n    /**\n     * Remove WebSocket Client\n     * @param id\n     */\n    removeClient(id) {\n        this.connections = this.connections.delete(id);\n    }\n\n\n    /**\n     * Listen WebSocket Clients\n     */\n\n    listenWebSocketClients() {\n\n        const wss = this.wss;\n\n\n        wss.on('connection', (ws) => {\n\n            // client is connected\n            const clientId = this.generateClientId();\n\n            const client = {\n                id: clientId,\n                ws: ws,\n                userId: null,\n                authenticated: false,\n            };\n\n            this.setClient(clientId, client);\n\n            ws.on('message', (message) => {\n                this.onMessage(clientId, message);\n\n            });\n\n            ws.on('close', () => {\n\n                this.onDisconnected(clientId);\n\n            });\n\n        });\n\n    }\n\n    /**\n     * Format message from string to json.\n     * @param message\n     * @returns {*}\n     */\n    messageToJson(message) {\n\n        let json = message;\n\n        try {\n            json = JSON.parse(json);\n        }\n        catch (err) {\n            console.log(\"Unable decode message to json\");\n        }\n\n        return json;\n    }\n\n\n    /**\n     * Listen Client message\n     * @param client\n     * @param message\n     */\n    onMessage(clientId, message) {\n\n        const client = this.getClient(clientId);\n\n        if (typeof message === 'string') {\n\n            message = this.messageToJson(message);\n\n            this.handleReceivedMessageEvent(client, message);\n\n        } else {\n            // this can be data message and we handle in future.\n\n        }\n    }\n\n    /**\n     * Process message events depend on action.\n     * @param client\n     * @param message\n     */\n    handleReceivedMessageEvent(client, message) {\n\n        const action = _.get(message, 'action', '');\n        const payload = _.get(message, 'payload');\n\n        switch (action) {\n\n            case 'auth':\n                // payload is access token id.\n                this.auth(client, payload);\n\n                break;\n\n            case 'logout':\n\n                this.logout(client);\n                break;\n            default:\n\n                break;\n        }\n    }\n\n    /**\n     * Handle sign out user\n     * @param client\n     * @param tokenId\n     */\n    logout(client) {\n\n        const userId = _.get(client, 'userId');\n        const tokenId = _.get(client, 'token._id');\n        client = _.setWith(client, 'authenticated', false);\n        client = _.setWith(client, 'userId', null);\n        client = _.setWith(client, 'token', null);\n        this.setClient(_.get(client, 'id'), client);\n        const clients = this.getClientsByUserId(userId);\n\n        if (userId && tokenId) {\n            if (!clients || clients.size === 1) {\n                // set status of user is offline.\n\n                this.ctx.models.user.updateAttribute(userId, {online: false}).then(() => {\n\n                    this.ctx.models.token.delete(tokenId).then(() => {\n\n                    });\n                });\n\n            }\n        }\n\n\n    }\n\n    /**\n     * Start check client with token.\n     * @param client\n     * @param token\n     */\n    auth(client, tokenId) {\n\n        if (this.isAuthenticated(client.id)) {\n            // client is already authenticated before.\n            this.authSuccess(client.id, client.token);\n\n        } else {\n\n            // let verify token\n            this.ctx.models.token.load(tokenId).then((token) => {\n                this.authSuccess(client.id, token);\n            }).catch(() => {\n                this.authError(client.id);\n            });\n\n        }\n\n\n    }\n\n    /**\n     * Client authenticated\n     * @param client\n     */\n    authSuccess(clientId, token) {\n\n        const client = this.getClient(clientId);\n\n        client.authenticated = true;\n        client.userId = token.userId;\n        client.token = token;\n        this.setClient(client.id, client);\n\n        // need update online of user.\n        const clients = this.getClientsByUserId(token.userId);\n\n\n        if (!clients || clients.size < 2) {\n            // set online\n            this.ctx.models.user.updateAttribute(token.userId, {online: true}).then(() => {\n\n            });\n        }\n\n\n        this.sendMessage(client, {action: 'auth_success', payload: client.token})\n    }\n\n    /**\n     * Client is not authenticated and error\n     * @param client\n     */\n    authError(clientId) {\n        const client = this.getClient(clientId);\n        client.authenticated = false;\n        client.token = null;\n\n        this.setClient(client.id, client); // update client to cache.\n\n        this.sendMessage(client, {action: 'auth_error', payload: \"Invalid Login Token\"});\n    }\n\n\n    /**\n     * Send a message to client.\n     * @param client\n     * @param message json data {action: string, payload: *}\n     */\n    sendMessage(client, message) {\n\n\n        if (!client || !client.ws) {\n            return\n        }\n\n\n        try {\n            message = JSON.stringify(message);\n        }\n        catch (err) {\n            console.log(\"An error convert object message to string.\");\n        }\n\n        client.ws.send(message);\n    }\n\n    /**\n     * On client disconnected\n     * @param clientId\n     */\n    onDisconnected(clientId) {\n\n\n        const client = this.getClient(clientId);\n        const userId = _.get(client, 'userId');\n        this.removeClient(client.id);\n\n        if (userId) {\n            // need update online of user.\n            const findClient = this.connections.find((con) => {\n                return _.toString(_.get(con, 'userId')) === _.toString(userId)\n            });\n\n            if (!findClient) {\n                // set user to offline.\n                this.ctx.models.user.updateAttribute(userId, {online: false}).then(() => {\n\n                });\n            }\n\n        }\n\n    }\n\n}"]}